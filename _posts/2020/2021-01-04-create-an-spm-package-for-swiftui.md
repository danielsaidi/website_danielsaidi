---
title:  "Create an SPM Package for SwiftUI"
date:   2020-01-04 12:00:00 +0100
tags:   spm swiftui
---

In this post, we'll create a package for the Swift Package Manager. The result will be a package that adds more gestures to `SwiftUI`. You can find the finished package [here][Project].

I will expand the package over time and add support for CocoaPods, Carthage, Fastlane and Bitrise in upcoming posts. At the end of this post, however, we'll have a fully functional package that can be used on iOS, tvOS, watchOS and macOS.


## Background

I have several open source projects and was very excited when Apple last WWDC announced that Swift Package Manager was coming to iOS. [CocoaPods][CocoaPods] and [Carthage][Carthage] are great dependency managers, but have problems that SPM has potential to solve, since it's integrated into Xcode.

However, it's still young and has many childhood problems. We will face a couple of them in this post, but save some of the nastier ones for future posts.


## Create the package

Let's start by creating a new Swift package. In the Terminal, create a new folder for our project, navigate to it and create the package within it:

```bash
mkdir SwiftUIGestures
cd SwiftUIGestures
swift package init
```

This will create a couple of files and folders:

* `.gitignote` - a standard, but badly configured git ignore file. We'll have to change this later. Read more [here][gitignore].
* `Package.swift` - a manifest file that describes your package.
* `Readme.md` - a basic readme for the package.
* `Sources` - Source files go here
* `Tests` - Unit tests go here

Unlike any apps youÃ¤ve worked with, this is a *package* and not an Xcode *project*. If you ask Xcode to open the folder, it will open the *package*, which has a structure that is different from projects.

We don't need a project for now, so let's do that in another post. Before we add functionality to our package, let's remove two files that are generated by SPM: `SwiftUIGestures.swift` and `SwiftUIGesturesTests.swift`. We will not use them.


## Create swipe gesture

Let's start by creating the class in which all the logic will go - `SwipeGesture`. 

Since we're using `SwiftUI`, we can build this as a view modifier, a view function etc. but since we're going to use `UIView`s and `UISwipeGestureRecognizer`s, let's go ahead and build it as a view, or rather as a `UIViewRepresentable`:

```swift
import SwiftUI
import UIKit

public struct SwipeGesture: UIViewRepresentable {

    typealias Context = UIViewRepresentableContext<SwipeGesture>

    public func makeUIView(context: Context) -> UIView {
        // Coming soon
    }

    public func updateUIView(_ uiView: UIView, context: Context) {}
}
```

The view should be able to trigger individual actions when it's being swiped in different directions. Let's define such an action as a simple typealias:

```swift
import Foundation

public extension SwipeGesture {
    
    typealias Action = () -> Void
}
```

This defines this action as a `SwipeGesture.Action`. Let's also create a struct that can hold all these gestures:

```swift
import Foundation

public extension SwipeGesture {
    
    struct Actions {
        
        init(
            up: @escaping Action = {},
            left: @escaping Action = {},
            right: @escaping Action = {},
            down: @escaping Action = {}) {
            self.up = up
            self.left = left
            self.right = right
            self.down = down
        }
        
        let up: Action
        let left: Action
        let right: Action
        let down: Action
    }
}
```

Users should have to define the swipe actions when the view is created. Let's add an initializer to enforce this:

```swift
public struct SwipeGesture: UIViewRepresentable {

    init(
        up: @escaping Action = {},
        left: @escaping Action = {},
        right: @escaping Action = {},
        down: @escaping Action = {}) {
        self.actions = Actions(up: up, left: left, right: right, down: down)
    }

    private let actions: Actions

    ...
}
```

The swipe gesture view should be a clear view that is only responsible to capture swipe gestures from the user. Let's start creating this view inside `makeUIView`:

```swift
public func makeUIView(context: Context) -> UIView {
    let view = UIView(frame: .zero)
    view.backgroundColor = .clear
    // Add gestures to the view
    return view
}
```

It's time to add gestures to the view, but since since `SwipeGesture` is a struct, we can't use it in the gesture selectors. To fix this, we can use a `coordinator`:

```swift
public extension SwipeGesture {
    
    class Coordinator: NSObject {
        
        public init(gesture: SwipeGesture) {
            self.gesture = gesture
        }
        
        private let gesture: SwipeGesture
        
        @objc public func swipeLeft() { gesture.actions.left() }
        @objc public func swipeRight() { gesture.actions.right() }
        @objc public func swipeUp() { gesture.actions.up() }
        @objc public func swipeDown() { gesture.actions.down() }
    }
    
    func makeCoordinator() -> SwipeGesture.Coordinator {
        Coordinator(gesture: self)
    }
}
```

This gives `makeUIView`'s `context` a `coordinator` of the above type, which we can use to setup our gestures. Let's create a `UIKit` extension that does this:

```swift
extension UIView {
    
    func addGesture(_ direction: UISwipeGestureRecognizer.Direction, target: Any?, action: Selector) {
        let swipe = UISwipeGestureRecognizer(target: target, action: action)
        swipe.direction = direction
        addGestureRecognizer(swipe)
    }
}
```

We can now use this extension to easily add gestures to the view in `makeUIView`:

```swift
public func makeUIView(context: Context) -> UIView {
    let view = UIView(frame: .zero)
    view.backgroundColor = .clear
    view.addGesture(.up, target: coordinator, action: #selector(coordinator.swipeUp))
    view.addGesture(.left, target: coordinator, action: #selector(coordinator.swipeLeft))
    view.addGesture(.right, target: coordinator, action: #selector(coordinator.swipeRight))
    view.addGesture(.down, target: coordinator, action: #selector(coordinator.swipeDown))
    return view
}
```

If you want to add a `SwipeGesture` to a `SwiftUI` view, you could just add it as an overlay, like this:

```swift
Color.red
    .overlay(
        SwipeGesture(
            up: { print("UP") },
            left: { print("LEFT") },
            right: { print("RIGHT") },
            down: { print("DOWN") }
        )
    )
)
```

However, this is not that nice compared to the built-in `onTapGesture` and `onLongPressGesture`. Let's create such a modifier for this gesture as well:

```swift
import SwiftUI

extension View {
    
    func onSwipeGesture(
        up: @escaping SwipeGesture.Action = {},
        left: @escaping SwipeGesture.Action = {},
        right: @escaping SwipeGesture.Action = {},
        down: @escaping SwipeGesture.Action = {}) -> some View {
        let gesture = SwipeGesture(up: up, left: left, right: right, down: down)
        return overlay(gesture)
    }
}
```

You can now add a `SwipeGesture` to any `SwiftUI` view like this:

```swift
Color.red
    .onSwipeGesture(
        up: { print("UP") },
        left: { print("LEFT") },
        right: { print("RIGHT") },
        down: { print("DOWN") }
    )
)
```

That's it! We now have a fully functional swipe gesture view, but we won't be able to test it until we have a demo project with preview or run capabilities.

Until then, let's bui...uh oh.


## Specify supported platforms

When you try to build the project (at least if you are doing this in early 2020), you'll notice that it won't build. The build will crash with an error:

```
'...' is only available in iOS 13.0 or newer
```

This error is because we're using `SwiftUI`, which is only available in the latest platform versions (iOS 13, tvOS 13, watchOS 6, macOS 10.10). You can silence this error with an `@available(iOS 13.0, *)`, but since this package is for SwiftUI, it doesn't really make sense.

Instead, let's add a requirement that the package can only be used in apps that target platforms that support SwiftUI.

Open `Package.json` and add the following code below `name`:

```
platforms: [
    .iOS(.v13),
    .tvOS(.v13),
    .watchOS(.v6),
    .macOS(.v10_15)
]
```

This tells the package that it can only be used on these particular platforms. Save the file, let Xcode refresh the package and you will now be able to build.


## Add unit tests

I use `Quick` and `Nimble` in most of my projects, but let's reduce complexity in this post by using `XCTests`.

Let's add a tiny test just to show that we can make the tests run. Let's unit test the `UIView+Gestures` extension that we defined earlier:

```swift
import UIKit

extension UIView {
    
    func addGesture(_ direction: UISwipeGestureRecognizer.Direction, target: Any?, action: Selector) {
        let swipe = UISwipeGestureRecognizer(target: target, action: action)
        swipe.direction = direction
        addGestureRecognizer(swipe)
    }
}
```

In `Tests/SwiftUIGestureTests`, add a `UIView+GesturesTests.swift` file with the following code:

```swift
import XCTest
@testable import SwiftUIGestures

final class UIView_GesturesTests: XCTestCase {
    
    func testVisualEffectViewIsCorrectlyAdded() {
        let view = UIView()
        let obj = TestClass()
        view.addGesture(.up, target: obj, action: #selector(obj.doStuff))
        
        let gestures = view.gestureRecognizers
        
        XCTAssertEqual(gestures?.count, 1)
        XCTAssertTrue(gestures?[0] is UISwipeGestureRecognizer)
    }
}

private class TestClass: NSObject {
    
    @objc func doStuff() {}
}
```

We need the `@testable import` since the extension is internal and can only be accessed within the library as well as in testable imports.

Now press `Cmd+U` and your tests should run without problems. As a good tester, you know that you always need more tests, but that's for another time.


## Run unit tests from the Terminal

Running SPM package tests from the terminal is super-easy! Just type `swift test`...just to see the following error:

```
.../SwipeGesture.swift:10:8: error: no such module 'UIKit'
import UIKit
       ^
```

Sadly, you can't run `UIKit`-based tests from the Terminal when you only have a package. Doing to will cause the test runner to crash, like above. I will describe how to fix this in a separate post.


## Publish the package

The last part now is to publish the package. This can easily be as much work as creating the package in the first place, since you should put effort into:

* `A great readme` to explain to people what your package is all about.
* `Document your code` to make it easy for people to use your package.
* `Create a stunning logo` to...well, you don't have to, but it's fun to try.

For now, though, just push it up to GitHub so that we can try it our in a  real Xcode project.


## Test the package in a project

We are now ready to create a new app project and see if our swipe gesture works.
Create a SwiftUI project for any platform you want: iOS, watchOS, tvOS or macOS, then add an SPM dependency to this package under `Project/Swift Packages`.

If you haven't published a package of your own, you can use this url instead: `https://github.com/danielsaidi/SwiftUIGestures`.

After Xcode has synced its SPM dependencies, you can now add `import SwiftUIGestures` to `ContentView` and add this code to it:

```swift
Color.red
    .onSwipeGesture(
        up: { print("UP") },
        left: { print("LEFT") },
        right: { print("RIGHT") },
        down: { print("DOWN") }
    )
)
```

If you run the project and swipe the red part of the screen, you should now get a printout of the direction you swiped. This means that everything worked well, and that the package is now ready to be used by the world. Congratulations - you have just created your first SWPM Package! ðŸ¥³


## Going further

You can find the package [here][Project]. I will expand it further in upcoming posts and will add the following to it in separate posts:

* CocoaPods support
* Carthage support
* Fastlane support
* A demo app
* Terminal support for unit tests

I hope that you have enjoyed this article and that it has given you valuable insights. Feel free to leave comments and feedback in the discussion section below.


[Carthage]: https://github.com/Carthage
[CocoaPods]: http://cocoapods.org

[Project]: https://github.com/danielsaidi/SwiftUIGestures
[gitignore]: https://danielsaidi.com/blog/2020/01/02/spm-gitignore